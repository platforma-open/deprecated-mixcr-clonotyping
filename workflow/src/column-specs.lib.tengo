maps := import("@platforma-sdk/workflow-tengo:maps")
ll := import("@platforma-sdk/workflow-tengo:ll")
utils := import(":utils")
text := import("text")

a := func(order, defaultVisibility, spec) {
	return maps.merge(spec, {
		"pl7.app/table/orderPriority": string(order),
		"pl7.app/table/visibility": defaultVisibility ? "default" : "optional"
	})
}

columnSpec := func(ops) {
	assemblingFeature := ops.assemblingFeature
	imputationEnabled := ops.imputationEnabled
	cellTags := ops.cellTags
	clonotypeKeyAxes := ops.clonotypeKeyAxes

	assemblingFeatureInfo := utils.assemblingFeatureInfo(assemblingFeature, imputationEnabled)
	productiveFeature := assemblingFeatureInfo.productiveFeature
	coreGeneFeatures := assemblingFeatureInfo.coreFeatures

	blockId := ops.blockId

	columnsSpec := []

	// Abundance

	columnsSpec += [
		{
			column: "readCount",
			id: "read-count",
			allowNA: false,
			spec: {
				name: "pl7.app/vdj/readCount",
				valueType: "Long",
				annotations: a(90000, true, {
					"pl7.app/min": "1",
					"pl7.app/label": "Number Of Reads"
				})
			}
		},
		{
			column: "readFraction",
			id: "read-fraction",
			allowNA: false,
			spec: {
				name: "pl7.app/vdj/readFraction",
				valueType: "Double",
				annotations: a(89000, true, {
					"pl7.app/min": "0",
					"pl7.app/max": "1",
					"pl7.app/label": "Fraction of reads"
				})
			}
		},
		{
			column: "uniqueMoleculeCount",
			id: "umi-count",
			allowNA: false,
			spec: {
				name: "pl7.app/vdj/uniqueMoleculeCount",
				valueType: "Long",
				annotations: a(88000, true, {
					"pl7.app/min": "1",
					"pl7.app/label": "Number of UMI"
				})
			}
		},
		{
			column: "uniqueMoleculeFraction",
			id: "umi-fraction",
			allowNA: false,
			spec: {
				name: "pl7.app/vdj/uniqueMoleculeFraction",
				valueType: "Double",
				annotations: a(87500, true, {
					"pl7.app/min": "0",
					"pl7.app/max": "1",
					"pl7.app/label": "Fraction of UMI"
				})
			}
		}
	]

	// VDJC Hits

	orderP := 80000
	for vdjcU in ["V", "D", "J", "C"] {
		vdjcL := text.to_lower(vdjcU)
		columnsSpec += [
			{
				column: "best" + vdjcU + "Hit",
				id: "best-" + vdjcL + "-hit",
				naRegex: "",
				allowNA: false,
				spec: {
					name: "pl7.app/vdj/geneHit",
					valueType: "String",
					domain: {
						"pl7.app/vdj/reference": vdjcU + "Gene"
					},
					annotations: a(orderP, true, {
						type: vdjcU + " gene name",
						"pl7.app/label": "Best " + vdjcU + " hit",
						"pl7.app/isDiscreteFilter": "true"
					})
				}
			}
		]
		orderP -= 100
	}

	// Sequences

	features := []
	if assemblingFeature != "CDR3" {
		features = [assemblingFeature, "CDR1", "FR1", "FR2", "CDR2", "FR3", "CDR3", "FR4"]
	} else {
		features = ["CDR3"]
	}

	for isImputed in [false, true] {
		imputedU := isImputed ? "Imputed" : ""
		imputedL := text.to_lower(imputedU)
		for featureU in features {
			featureL := text.to_lower(featureU)
			for isAminoAcid in [false, true] {
				alphabet := isAminoAcid ? "aminoacid" : "nucleotide"
				alphabetShort := isAminoAcid ? "aa" : "nt"
				alphabetShortMixcr := isAminoAcid ? "aa" : "n"
				visibility := ((featureU == "CDR3") || (featureU == assemblingFeature)) ? true : false
				columnsSpec += [
					{
						column: alphabetShortMixcr + "Seq" + imputedU + featureU,
						id: alphabetShortMixcr + "-seq-" + featureL + "-" + imputedL,
						naRegex: "region_not_covered",
						spec: {
							name: "pl7.app/vdj/sequence",
							valueType: "String",
							domain: {
								"pl7.app/vdj/feature": featureU,
								"pl7.app/alphabet": alphabet
							},
							annotations: a(orderP, visibility, {
								"pl7.app/vdj/imputed": string(isImputed),
								"pl7.app/label": featureU + " " + alphabetShort
							})
						}
					}
				]
				if !isImputed && !isAminoAcid {
					columnsSpec += [
						{
							column: "minQual" + featureU,
							id: "min-qual-" + featureL,
							naRegex: "region_not_covered",
							spec: {
								name: "pl7.app/vdj/sequenceQuality",
								valueType: "Int",
								domain: {
									"pl7.app/vdj/quality": "minQuality",
									"pl7.app/vdj/feature": featureU
								},
								annotations: a(orderP - 10, false, {
									"pl7.app/min": "0",
									"pl7.app/max": "60",
									"pl7.app/label": "Min quality " + featureU
								})
							}
						}
					]
				}
				orderP -= 100
			}
		}
	}

	// Mutations

	orderP = 10000

	for isAminoAcid in [false, true] {
		alphabetShort := isAminoAcid ? "AA" : "Nt"
		alphabetShortMixcr := isAminoAcid ? "aa" : "n"

		// Now loop over gene types.
		for geneU in ["V", "J"] {
			geneL := text.to_lower(geneU)

			coreFeature := coreGeneFeatures[geneU]
			if is_undefined(coreFeature) {
				continue
			}

			mutationGroups := [ {
					group: "Mutations",
					valueType: "String",
					specName: "pl7.app/vdj/sequence/" + alphabetShortMixcr + "Mutations",
					label: alphabetShort + " mutations in " + geneU + " gene",
					id: alphabetShortMixcr + "-mutations-" + geneL
				}, {
					group: "MutationsCount",
					valueType: "Int",
					specName: "pl7.app/vdj/sequence/" + alphabetShortMixcr + "MutationsCount",
					label: alphabetShort + " mutations count in " + geneU + " gene",
					id: alphabetShortMixcr + "-mutations-count-" + geneL
				}, {
					group: "MutationsRate",
					valueType: "Double",
					specName: "pl7.app/vdj/sequence/" + alphabetShortMixcr + "MutationsRate",
					label: alphabetShort + " mutations rate in " + geneU + " gene",
					id: alphabetShortMixcr + "-mutations-rate-" + geneL
				} ]

			for group in mutationGroups {
				columnsSpec += [ {
						column: alphabetShortMixcr + group.group + coreFeature,
						id: group.id,
						allowNA: true,
						naRegex: "region_not_covered",
						spec: {
							valueType: group.valueType,
							name: group.specName,
							annotations: a(orderP, false, {
								"pl7.app/label": group.label
							})
						}
					} ]
				orderP -= 100
			}
		}
	}

	// Flags: productive, oof, stop codons

	columnGroups := [ {
			columns: "isProductive" + productiveFeature,
			valueType: "String",
			specName: "pl7.app/vdj/sequence/productive",
			label: "Productive",
			id: "is-productive",
			visibility: true
		}, {
			group: "Contains OOF",
			columns: "isOOF" + productiveFeature,
			valueType: "String",
			specName: "pl7.app/vdj/sequence/containsOOF",
			label: "Contains OOF",
			id: "is-oof",
			visibility: false
		}, {
			group: "Contains stop codons",
			columns: "hasStopsIn" + productiveFeature,
			valueType: "String",
			specName: "pl7.app/vdj/sequence/containsStopCodons",
			label: "Contains stop codons",
			id: "has-stops",
			visibility: false
		} ]
	for group in columnGroups {
		columnsSpec += [ {
				column: group.column,
				id: group.id,
				allowNA: false,
				spec: {
					valueType: group.valueType,
					name: group.specName,
					annotations: a(orderP, group.visibility, {
						"pl7.app/label": group.label,
						"pl7.app/isDiscreteFilter": "true",
						"pl7.app/discreteValues": "['true','false']" } )
				}
			} ]
		orderP -= 100
	}

	// Germline sequences

	geneRegions := ["VRegion", "DRegion", "JRegion"]

	for region in geneRegions {
		columnsSpec += [ {
				column: "nSeq" + region + "OfGermline",
				id: "n-seq-" + text.to_lower(region) + "-germline",
				spec: {
					name: "pl7.app/vdj/germlineSequence",
					valueType: "String",
					domain: {
						"pl7.app/vdj/feature": region,
						"pl7.app/alphabet": "nucleotide"
					},
					annotations: a(orderP, false, {
						"pl7.app/label": region[0:1] + " germline"
					})
				}
			} ]
		orderP -= 100
	}

	// Isotype and chain

	columnsSpec += [ {
			column: "isotype",
			id: "isotype",
			naRegex: "",
			spec: {
				valueType: "String",
				name: "pl7.app/vdj/isotype",
				annotations: a(orderP, true, {
					"pl7.app/label": "IG isotype",
					"pl7.app/isDiscreteFilter": "true"
				})
			}
		}, {
			column: "topChains",
			id: "top-chains",
			naRegex: "",
			allowNA: false,
			spec: {
				valueType: "String",
				name: "pl7.app/vdj/chain",
				annotations: a(orderP, true, {
					"pl7.app/label": "Chain",
					"pl7.app/isDiscreteFilter": "true",
					"pl7.app/discreteValues": "['TRA','TRB','TRG','TRD','IGH','IGK','IGL']"
				})
			}
		} ]

	// Axes

	axesSpec := undefined
	if !is_undefined(clonotypeKeyAxes) {
		ll.assert(is_undefined(cellTags) || len(cellTags) == 0, "cellTags and clonotypeKeyAxes cannot both be defined")
		axesSpec = [ {
				column: "clonotypeKey",
				naRegex: "",
				spec: {
					name: "pl7.app/vdj/clonotypeKey",
					type: "String",
					domain: {
						"pl7.app/vdj/clonotypeKey/structure": text.join(clonotypeKeyAxes, "-")
					},
					annotations: {
						"pl7.app/label": "Clonotype key",
						"pl7.app/table/visibility": "optional",
						"pl7.app/table/orderPriority": "110000"
					}
				}
			} ]
	} else {
		axesSpec = [ {
			column: "cloneId",
			spec: {
				name: "pl7.app/vdj/cloneId",
				type: "Long",
				domain: {
					"pl7.app/blockId": blockId
				},
				annotations: {
					"pl7.app/min": "0",
					"pl7.app/label": "Clone id",
					"pl7.app/table/visibility": "optional",
					"pl7.app/table/orderPriority": "90000"
					}
				}
			} ]

		orderP := 100000
		if !is_undefined(cellTags) && len(cellTags) > 0 {
			for tag in cellTags {
				label := undefined
				if tag == "CELL" {
					label = "Cell tag"
				} else {
					label = text.to_title(tag[:4]) + " " + text.to_lower(tag[4:])
				}
				axesSpec += [ {
						column: "tagValue" + tag,
						naRegex: "",
						spec: {
							name: "pl7.app/vdj/cellTag",
							type: "String",
							domain: {
								"pl7.app/vdj/cellTagId": tag,
								"pl7.app/blockId": blockId
							},
							annotations: a(orderP, true, {
								"pl7.app/label": label
							})
						}
					} ]
				orderP -= 1
			}
		}
	}

	// columnSpecMap := {}
	// for columnSpec in columnsSpec {
	// 	columnSpecMap[columnSpec.id] = columnSpec
	// }
	// for axisSpec in axesSpec {
	// 	columnSpecMap[axisSpec.id] = axisSpec
	// }

	return {
		axesSpec: axesSpec,
		columnsSpec: columnsSpec
	}
}

export ll.toStrict({
	columnSpec: columnSpec
})
