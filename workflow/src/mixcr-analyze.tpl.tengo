// mixcr analyze

self := import("@milaboratory/tengo-sdk:tpl")
pConstants := import("@milaboratory/tengo-sdk:pframes.constants")
ll := import("@milaboratory/tengo-sdk:ll")
exec := import("@milaboratory/tengo-sdk:exec")
smart := import("@milaboratory/tengo-sdk:smart")

json := import("json")

self.defineOutputs("qc")

self.body(func(inputs) {
	inputData := inputs[pConstants.VALUE_FIELD_NAME]

	params := inputs.params
	preset := params.preset
	fileExtension := params.fileExtension
	reports := params.reports

	presetContent := inputs.presetContent.getDataAsJson()
	pfconvParams := inputs.pfconvParams // already in JSON

	if !is_map(presetContent) {
		ll.panic("malformed presetContent %v", presetContent)
	}

	if !is_map(pfconvParams) {
		ll.panic("malformed pfconvParams %v", pfconvParams)
	}

	inputDataMeta := inputData.getDataAsJson()

	if inputDataMeta.keyLength == 1 {
		mixcrCmdBuilder := exec.builder().
								printErrStreamToStdout().
						        cmd("mixcr").
						        arg("analyze").
								arg(preset)

		for sKey, inputFile in inputData.inputs() {
			key := json.decode(sKey)
			r := key[0]
			if (r[0] != 'R' && r[0] != "I") || (r[1] != '1' && r[1] != '2') || len(r) != 2 {
				ll.panic("malformed read index: %v", r)
			}
			fileName := "input_" + r + "." + fileExtension
			mixcrCmdBuilder.addFile(fileName, inputFile).
							arg(fileName)
		}

		mixcrCmdBuilder.arg("result")

		mixcrCmdBuilder.saveFile("result.qc.json")

		for report in reports {
			mixcrCmdBuilder.saveFile(report.fileJson)
			mixcrCmdBuilder.saveFile(report.fileTxt)
		}

		mixcrCmd := mixcrCmdBuilder.run()

		reportsMap := smart.structBuilder(
			pConstants.RTYPE_P_COLUMN_DATA_RESOURCE_MAP,
			json.encode({ keyLength: groupKeyLength })
		)
		for report in reports {
			reportsMap.createInputField(json.encode([report.id, "json"])).set(mixcrCmd.saveFile(report.fileJson))
			reportsMap.createInputField(json.encode([report.id, "txt"])).set(mixcrCmd.saveFile(report.fileTxt))
		}

		return {
			qc: mixcrCmd.getFile("result.qc.json"),
			reports: reportsMap.lockAndBuild()
		}
	} else {
		ll.panic("not yet supported")
	}
})
