// calculate-pfconv-params
self := import("@platforma-sdk/workflow-tengo:tpl")
// validation := import("@platforma-sdk/workflow-tengo:validation")
maps := import("@platforma-sdk/workflow-tengo:maps")
ll := import("@platforma-sdk/workflow-tengo:ll")

pfconvParamsLib := import(":pfconv_params")
getFeature := import(":check-feature")

json := import("json")
text := import("text")

// self.validateInputs({
// 	"__options__,closed": "",
// 	request: {
// 		"__options__,closed": "",
// 		blockId: ["not", validation.resource()],
// 		"specs,omitempty": ["not", validation.resource()]
// 	}
// })

self.defineOutputs("params", "featureParams", "clonotypeKeyColumns")

toCombinedDomainKey := func(spec) {
	result := [spec.name]
	// getKeys sort keys
	for domain in maps.getKeys(spec.domain) {
		result = append(result, [domain, spec.domain[domain]])
	}
	return result
}

self.body(func(inputs) {

	blockId := inputs.blockId

	// filter function
	filter := func(list, predicate) {
		result := []
		for item in list {
			if predicate(item) {
				result = append(result, item)
			}
		}
		return result
	}

	// contains function
	contains := func(list, value) {
		for item in list {
			if item == value {
				return true
			}
		}
		return false
	}

	fieldsToColumns := {
		"-cellGroup": "cellGroup",
		"-topChains": "topChains",
		"-isotype": "isotype",
		"-vHit": "bestVHit",
		"-dHit": "bestDHit",
		"-jHit": "bestJHit",
		"-cHit": "bestCHit"
	}

	// get specs and preset data
	specs := inputs.specs.getDataAsJson()
	preset := inputs.preset.getDataAsJson()

	// extract covered feature
	imputed := false
	assemblingFeature := undefined
	if !is_undefined(specs.assemblingFeature) {
		assemblingFeature = specs.assemblingFeature[0]
	} else {
		assemblingFeature = "VDJRegion"
		imputed = true
	}

	//if using readCount or umiCount
	columnsList := []
	hasUmi := false
	if len(specs.umiTags) == 0 {
		columnsList += ["readCount", "readFraction"]
	} else {
		hasUmi = true
		columnsList += ["uniqueMoleculeCount", "uniqueMoleculeFraction", "readCount", "readFraction"]
	}

	// filter columns by fieldsToColumns
	for field in preset.exportClones.fields {
		if !is_undefined(fieldsToColumns[field.field]) {
			columnsList = append(columnsList, fieldsToColumns[field.field])
		}
	}

	// add columns with frameworks, cdrs sequences
	for feature in specs.coveredFeaturesOnExport {
		if imputed {
			if feature == "CDR3" {
				columnsList += ["nSeq"+feature, "aaSeq"+feature]
			} else {
				columnsList += ["nSeqImputed"+feature, "aaSeqImputed"+feature,
					"nSeq"+feature, "aaSeq"+feature]
			}
		} else {
			columnsList += ["nSeq"+feature, "aaSeq"+feature]
		}
	}

	// add columns with covered feature sequences
	if assemblingFeature != "CDR3" {
		columnsList += ["nSeq"+assemblingFeature, "aaSeq"+assemblingFeature]
		if imputed {
			columnsList += ["nSeqImputed"+assemblingFeature, "aaSeqImputed"+assemblingFeature]
		}
	}

	// add V, D, J germline sequences
	columnsList += ["nSeqVRegionOfGermline", "nSeqDRegionOfGermline", "nSeqJRegionOfGermline"]

	// add boolean columns (isProductive, hasStops, hasOOF)
	featureSpec := getFeature.getProductiveFeature(assemblingFeature, imputed)
	productiveFeature := featureSpec.productiveFeature
	columnsList += ["isProductive"+productiveFeature, "isOOF"+productiveFeature, "hasStopsIn"+productiveFeature]

	// add columns with mutations
	if assemblingFeature != "CDR3" {
		mutationVFeature := featureSpec.mutationVFeature
		columnsList += ["nMutations"+mutationVFeature, "aaMutations"+mutationVFeature, "nMutationsCount"+mutationVFeature,
			"aaMutationsCount"+mutationVFeature, "nMutationsRate"+mutationVFeature, "aaMutationsRate"+mutationVFeature,
			"nMutationsFR4", "aaMutationsFR4", "nMutationsCountFR4", "aaMutationsCountFR4", "nMutationsRateFR4", "aaMutationsRateFR4"]
	}

	//create key columns
	clonotypeKeyColumns := ["nSeq"+assemblingFeature]
	if specs.splitByV {
		clonotypeKeyColumns = append(clonotypeKeyColumns, "bestVHit")
	}
	if specs.splitByJ {
		clonotypeKeyColumns = append(clonotypeKeyColumns, "bestJHit")
	}
	if specs.splitByC {
		clonotypeKeyColumns = append(clonotypeKeyColumns, "bestCHit")
	}

	// filter pfconvParams by column name and get a list of fields from it
	pfconvParams := pfconvParamsLib.getColumns(blockId, {assemblingFeature: assemblingFeature, imputed: imputed, cellTags: specs.cellTags, clonotypeKeyColumns: clonotypeKeyColumns})
	// column (i.e. in tsv) -> pfconv params
	columnsMap := {}
	axesMap := {}
	for col in pfconvParams.columns {
		columnsMap[col.column] = col
	}
	for axis in pfconvParams.axes {
		axesMap[axis.column] = axis
	}

	ll.print("__THE_LOG__ " + columnsList)
	columns := []
	for col in columnsList {
		// getColumn := filter(pfconvParams.columns, func(item) { return item.column == col})
		columns += [columnsMap[col]] // getColumn
	}

	// if UMI in data make visibility of "readCount" and "readFraction" columns optional
	targetColumns := ["readCount", "readFraction"]

	if hasUmi {
		for column in columns {
			if contains(targetColumns, column.column) {
				column.spec.annotations["pl7.app/table/visibility"] = "optional"
			}
		}
	}

	// create axes fields
	axes := []
	if len(specs.cellTags) == 0 {
		axes = [axesMap["cloneId"], axesMap[text.join(clonotypeKeyColumns, "-")]] // filter(pfconvParams.axes, func(item) { return item.column == "cloneId" })
	} else {
		axes = pfconvParams.axes
	}

	return {
		params: {
			axes: axes,
			columns: columns,
			storageFormat: "Binary",
			partitionKeyLength: 0
		},
		clonotypeKeyColumns: clonotypeKeyColumns,
		featureParams: {
			assemblingFeature: assemblingFeature,
			imputed: imputed
		}
	}
})
