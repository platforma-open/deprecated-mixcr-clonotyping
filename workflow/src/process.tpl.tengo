// process

self := import("@platforma-sdk/workflow-tengo:tpl")

ll := import("@platforma-sdk/workflow-tengo:ll")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
smart := import("@platforma-sdk/workflow-tengo:smart")
file := import("@platforma-sdk/workflow-tengo:file")
llPFrames := import("@platforma-sdk/workflow-tengo:pframes.ll")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
pUtil := import("@platforma-sdk/workflow-tengo:pframes.util")
pConstants := import("@platforma-sdk/workflow-tengo:pframes.constants")

json := import("json")
text := import("text")

mixcrAnalyzeTpl := assets.importTemplate(":mixcr-analyze")

self.awaitState("InputsLocked")
self.awaitState("params", "ResourceReady")
self.awaitState("inputSpec", "ResourceReady")
self.awaitState("presetContent", "ResourceReady")
self.awaitState("pfconvParamsById", "ResourceReady")
self.awaitState("pfconvParamsByKey", "ResourceReady")
self.awaitState("featureParams", "ResourceReady")
self.awaitState("clonotypeKeyAxes", "ResourceReady")

self.body(func(inputs) {
	params := inputs.params
	preset := inputs.preset
	inputSpec := inputs.inputSpec
	featureParams := inputs.featureParams
	clonotypeKeyAxes := inputs.clonotypeKeyAxes
	library := inputs.library
	species := params.species
	limitInput := params.limitInput
	blockId := params.blockId
	presetCommonName := params.presetCommonName
	isLibraryFileGzipped := params.isLibraryFileGzipped

	presetContent := inputs.presetContent.getDataAsJson()
	pfconvParamsById := inputs.pfconvParamsById
	pfconvParamsByKey := inputs.pfconvParamsByKey

	if is_undefined(presetContent) {
		ll.panic("no presetContent")
	}

	if is_undefined(pfconvParamsById) || is_undefined(pfconvParamsByKey) {
		ll.panic("no pfconvParams")
	}

	reports := []

	for step in presetContent.reportTypes {
		if step == "align" || step == "assemble" {
			reports = append(reports, {
				id: step,
				fileJson: "result." + step + ".report.json",
				fileTxt: "result." + step + ".report.txt"
			})
		}
	}

	hasAssembleContigs := false
	hasAssembleCells := false
	for stage in presetContent.analysisStages {
		if stage == "assembleContigs" {
			hasAssembleContigs = true
		} else if stage == "assembleCells" {
			hasAssembleCells = true
		}
	}

	// calculating clns annotations

	joinOrUndefined := func(arr) {
		if is_undefined(arr) {
			return undefined
		} else {
			return text.join(arr, ",")
		}
	}

	removeUndefined := func(m) {
		r := {}
		for k, v in m {
			if !is_undefined(v) {
				r[k] = v
			}
		}
		return r;
	}

	clnsAnnotations := removeUndefined({
		"mixcr.com/assemblingFeature": joinOrUndefined(presetContent.assemblingFeature),
		"mixcr.com/cellTags": joinOrUndefined(presetContent.cellTags),
		"mixcr.com/coveredFeaturesOnExport": joinOrUndefined(presetContent.coveredFeaturesOnExport),
		"mixcr.com/umiTags": joinOrUndefined(presetContent.umiTags),
		"pl7.app/label": "MiXCR Clonesets"
	})
	if hasAssembleContigs {
		clnsAnnotations["mixcr.com/contigsAssembled"] = "true"
	}
	if hasAssembleCells {
		clnsAnnotations["mixcr.com/cellsAssembled"] = "true"
	}

	cColumnsAdditionalAxesSpec := []
	if !hasAssembleCells {
		cColumnsAdditionalAxesSpec = append(cColumnsAdditionalAxesSpec, {
			"name": "pl7.app/vdj/chain",
			"type": "String",
			"annotations": {
				"pl7.app/label": "Chain",
				"pl7.app/axisNature": "scaleCompatible"
			}
		})
	}


	decompositionById := pUtil.decomposePfconvImportCfg(pfconvParamsById, {
		additionalAxesSpec: cColumnsAdditionalAxesSpec
	})
	purifiedPfconvByIdCfg := decompositionById.purifiedCfg
	cloneColumnsByIdSpec := decompositionById.columnsSpec
	decompositionByKey := pUtil.decomposePfconvImportCfg(pfconvParamsByKey, {
		additionalAxesSpec: cColumnsAdditionalAxesSpec
	})
	purifiedPfconvByKeyCfg := decompositionByKey.purifiedCfg
	cloneColumnsByKeySpec := decompositionByKey.columnsSpec

	fileExtension := inputSpec.domain["pl7.app/fileExtension"]

	targetOutputs := [ {
		type: "Resource",
		spec: {
			kind: "PColumn",
			valueType: "File",
			name: "mixcr.com/qc",
			domain: {
				"pl7.app/blockId": blockId
			}
		},
		name: "qc"
	}, {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "pl7.app/log",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "Log"
		},
		name: "log"
	}, {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "mixcr.com/clns",
			domain: {
				"pl7.app/blockId": blockId
			},
			annotations: clnsAnnotations,
			valueType: "File"
		},
		name: "clns"
	}, {
		type: "ResourceMap",
		name: "reports",
		spec: {
			kind: "PColumn",
			name: "mixcr.com/report",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "File",
			axesSpec: [ {
				type: "String",
				name: "mixcr.com/report/source",
				annotations: {
					"pl7.app/label": "Source MiXCR stage"
				}
			}, {
				type: "String",
				name: "mixcr.com/report/format",
				annotations: {
					"pl7.app/label": "Report format"
				},
				domain: {
					"pl7.app/dense": string(json.encode(["json", "txt"]))
				}
			} ]
		}
	} ]

	ll.assert(purifiedPfconvByIdCfg.partitionKeyLength == 0, "unexpected partition length")
	ll.assert(purifiedPfconvByIdCfg.storageFormat == "Binary", "unexpected format")
	ll.assert(purifiedPfconvByKeyCfg.partitionKeyLength == 0, "unexpected partition length")
	ll.assert(purifiedPfconvByKeyCfg.storageFormat == "Binary", "unexpected format")

	innerPartitionLength := 0
	if !hasAssembleCells {
		innerPartitionLength = 1 // [chain]
	}

	for columnCfg in purifiedPfconvByIdCfg.columns {
		aggCfg := {
			type: "BinaryPartitioned",
			name: "clonesById/" + columnCfg.id,
			path: ["clonesById", columnCfg.id],
			spec: cloneColumnsByIdSpec[columnCfg.id],
			partitionKeyLength: innerPartitionLength
		}
		targetOutputs = append(targetOutputs, aggCfg)
	}

	for columnCfg in purifiedPfconvByKeyCfg.columns {
		aggCfg := {
			type: "BinaryPartitioned",
			name: "clonesByKey/" + columnCfg.id,
			path: ["clonesByKey", columnCfg.id],
			spec: cloneColumnsByKeySpec[columnCfg.id],
			partitionKeyLength: innerPartitionLength
		}
		targetOutputs = append(targetOutputs, aggCfg)
	}

	mixcrResults := pframes.processColumn(
		{ spec: inputSpec, data: inputs.inputData },
		mixcrAnalyzeTpl,
		targetOutputs,
		{
			aggregate: [{
				name: "pl7.app/sequencing/lane",
				optional: true
			}, {
				name: "pl7.app/sequencing/readIndex",
				optional: true
			}],
			// resulting aggregation axes names will be checked against supported combinations
			// in the body template
			passAggregationAxesNames: true,

			// will be automatically propagated to all output specs
			traceSteps: [{type: "milaboratories.mixcr-clonotyping", id: blockId, importance: 20, label: "MiXCR " + presetCommonName}],

			extra: {
				preset: preset,
				params: {
					species: species,
					limitInput: limitInput,
					fileExtension: fileExtension,
					reports: reports,
					featureParams: featureParams,
					isLibraryFileGzipped: isLibraryFileGzipped
				},
				clonotypeKeyAxes: clonotypeKeyAxes,
				library: library,
				presetContent: presetContent,
				pfconvParamsById: purifiedPfconvByIdCfg,
				pfconvParamsByKey: purifiedPfconvByKeyCfg
			}
		}
	)

	clones := pframes.pFrameBuilder()
	for columnId, columnSpec in cloneColumnsByIdSpec {
		clones.add(columnId,
				mixcrResults.outputSpec("clonesById/" + columnId),
				mixcrResults.outputData("clonesById/" + columnId))
	}
	if !hasAssembleCells {
		for columnId, columnSpec in cloneColumnsByKeySpec {
			clones.add(columnId,
					mixcrResults.outputSpec("clonesByKey/" + columnId),
					mixcrResults.outputData("clonesByKey/" + columnId))
		}
	}
	clones = clones.build()

	return {
		"qc.spec": mixcrResults.outputSpec("qc"),
		"qc.data": mixcrResults.outputData("qc"),

		"logs.spec": mixcrResults.outputSpec("log"),
		"logs.data": mixcrResults.outputData("log"),

		"reports.spec": mixcrResults.outputSpec("reports"),
		"reports.data": mixcrResults.outputData("reports"),

		"clns.spec": mixcrResults.outputSpec("clns"),
		"clns.data": mixcrResults.outputData("clns"),

		"clones": clones
	}
})
