ll := import("@platforma-sdk/workflow-tengo:ll")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets := import("@platforma-sdk/workflow-tengo:assets")
json := import("json")
text := import("text")

paggregateSw := assets.importSoftware("@platforma-open/milaboratories.software-ptransform:main")



/**
 * Converts an assembling feature into corresponding productive feature and core features formats.
 * This function handles different immunological feature types (CDR3, VDJRegion, etc.) and
 * returns properly formatted feature expressions based on the input.
 *
 * @param assemblingFeature - The input feature identifier (e.g., "CDR3", "VDJRegion", "FR1_TO_FR4")
 * @param imputed - Boolean flag indicating if the feature is imputed
 * @return An object containing:
 *   - productiveFeature: formatted identifier for the productive feature
 *   - coreGeneFeatures: an object containing core features used for mutation analysis:
 *     - V: formatted identifier for the V gene core feature
 *     - J: formatted identifier for the J gene core feature (if applicable)
 */
assemblingFeatureInfo := func(assemblingFeature, imputed) {
	productiveFeature := undefined
	coreVFeature := undefined
	coreJFeature := undefined
	if assemblingFeature == "CDR3" || imputed {
		productiveFeature = "CDR3"
	} else if assemblingFeature == "VDJRegion" {
		productiveFeature = "VDJRegion(0,-1)"
		coreVFeature = "{FR1Begin:FR3End}"
		coreJFeature = "FR4"
	} else {
		splittedFeature := text.split(assemblingFeature, "_TO_")
		if len(splittedFeature) == 2 {
			if splittedFeature[1] == "FR4" {
				productiveFeature = "{"+splittedFeature[0] + "Begin:FR4End(-1)}"
				coreVFeature = "{"+splittedFeature[0]+"Begin:FR3End}"
				coreJFeature = "FR4"
			} else {
				productiveFeature = assemblingFeature
				coreVFeature = "{"+splittedFeature[0]+"Begin:FR3End}"
			}
		}
	}
	return {
		productiveFeature: productiveFeature,
		coreGeneFeatures: {
			V: coreVFeature,
			J: coreJFeature
		}
	}
}

/**
 * Adds a clone key column to the input TSV file by combining the values of the specified key columns.
 *
 * @param inputTsv - The input TSV file to add the clone key column to.
 * @param keyColumns - The columns to combine to create the clone key.
 * @return The output TSV file with the clone key column added.
 */
addCloneKey := func(inputTsv, keyColumns) {
    aggregationWorkflow := {
        steps: [
            {
                type: "combine_columns_as_json",
                src: keyColumns,
                dst: "clonotypeKey"
            }
        ]
    }

    aggregateCmd := exec.builder().
        printErrStreamToStdout().
        software(paggregateSw).
        arg("--workflow").arg("wf.json").
        writeFile("wf.json", json.encode(aggregationWorkflow)).
        arg("input.tsv").addFile("input.tsv", inputTsv).
        arg("output.tsv").saveFile("output.tsv").
        run()

    return aggregateCmd.getFile("output.tsv")
}

export ll.toStrict({
	addCloneKey: addCloneKey,
    assemblingFeatureInfo: assemblingFeatureInfo
})
